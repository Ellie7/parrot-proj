## This script follows the matrix population model methods in Crouse 1987 to produce equivalent analyses.

## Reference
## Title: A Stage-Based Population Model for Loggerhead Sea Turtles and Implications for Conservation
## Author(s): Deborah T. Crouse, Larry B. Crowder and Hal Caswell
## Source: Ecology, Vol. 68, No. 5 (Oct., 1987), pp. 1412-1423
## Published by: Ecological Society of America
## Stable URL: http://www.jstor.org/stable/1939225

rm(list=ls())

library(dplyr)
library(ggplot2)
library(gridExtra)
source("loggerhead_fun.R")

turtleData <- read.csv("loggerhead.crouse1987.csv") %>%
  mutate(stage.length = max.age - min.age)

A <- with(turtleData, createProjectionMatrix(surv, fecund, stage.length))
A

## Crouse 1987 calculates the eigenvalues and eigenvectors using the power
## method (Searle 1966, Keyfitz 1977).
## (See p205 of Trefethen and Bau for this algorithm, which the authors note is
## not a very effective method for finding eigenvalues/eigenvectors.)
## Here we'll use just use eigen() to get our eigenvalues and vectors. This
## gives a reasonably good approximation to the values of lambda_m= 0.9450 and
## r = -0.0565 generated by Crouse.
eig <- eigen(A, symmetric = FALSE)
lambda <- Re(eig$values[1])
(r <- log(lambda))

## The stable stage distribution is given by the right eigenvector (coerced here
## to its real part).
w1 <- Re(eig$vectors[,1])
turtleData <- mutate(turtleData, stage.dist = w1/sum(w1))

ggplot(turtleData, aes(x = stage, y = stage.dist))+
  geom_bar(stat="identity", fill="cornflowerblue", width = 0.8)+
  xlab("Stage")+
  ylab("Proportion of individuals")+
  scale_x_discrete(limits=turtleData$class)+
  #scale_y_continuous(limits=c(0, 1))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45, hjust=1, size=12),
        axis.line.x = element_line(lineend = 0.5))

## The reproductive value is given by the left eigenvector, which we get by
## calculating the eigenvectors of the transpose of the projection matrix.
v1 <- eigen(t(A), symmetric = FALSE)$vectors[,1]
repro_value <- Re(v1/v1[1])
repro_value

## Mean reproductive value
repro_value %*% turtleData$stage.dist

## Sensitivity analyses
perm <- rbind(c(1,0), cbind(F=0, S=1:7))
sens.grow <- t(apply(perm, MARGIN = 1, function(x) {
  td <- turtleData %>% mutate(surv.dec = ifelse(stage==x["S"], surv*0.5, surv),
                              fecund.dec = ifelse(x["F"],0.5,1)*fecund,
                              surv.inc = ifelse(stage==x["S"], 0.99, surv),
                              fecund.inc = ifelse(x["F"],1.5,1)*fecund)
  
  A <- with(td, createProjectionMatrix(surv.dec, fecund.dec, stage.length))
  eig <- eigen(A, symmetric = FALSE)
  r.dec <- Re(log(eig$values[1]))
  
  A <- with(td, createProjectionMatrix(surv.inc, fecund.inc, stage.length))
  eig <- eigen(A, symmetric = FALSE)
  r.inc <- Re(log(eig$values[1]))
  
  return(c(grow.dec=r.dec, grow.inc=r.inc))
}))
sens.grow <- data.frame(perm,sens.grow)

lim=c(min(sens.grow$grow.dec, sens.grow$grow.inc),
      max(sens.grow$grow.dec, sens.grow$grow.inc))

p1 <- ggplot(sens.grow, aes(x = S+1, y = grow.dec))+
  geom_bar(stat="identity", position = "identity",
           fill="grey", width = 0.8)+
  geom_abline(slope = 0, intercept = 0)+
  geom_abline(slope = 0, intercept = r, linetype="dotted")+
  ggtitle("Decrease in fecundity or survivorship")+
  xlab("Vital rate parameter")+
  ylab("Intrinic rate of increase")+
  scale_x_discrete(limits=c("fecundity", as.character(turtleData$class)))+
  scale_y_continuous(limits=lim)+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45, hjust=1, size=10),
        axis.title = element_text(hjust=0.5),
        title = element_text(size=9.5, face='bold'))

p2 <- ggplot(sens.grow, aes(x = S+1, y = grow.inc))+
  geom_bar(stat="identity", position = "identity",
           fill="grey", width = 0.8)+
  geom_abline(slope = 0, intercept = 0)+
  geom_abline(slope = 0, intercept = r, linetype="dotted")+
  ggtitle("Increase in fecundity or survivorship")+
  xlab("Vital rate parameter")+
  ylab("Intrinic rate of increase")+
  scale_x_discrete(limits=c("fecundity", as.character(turtleData$class)))+
  scale_y_continuous(limits=lim)+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45, hjust=1, size=10),
        axis.title = element_text(hjust=0.5),
        title = element_text(size=9.5, face='bold'))

grid.arrange(p1, p2, ncol=1)

## Age at first repro sensitivity
ages <- seq(-6,6,by=2)
ages[1] <- -5.99
sens.age <- sapply(ages, function(x) {
  td <- turtleData %>% mutate(stage.length = ifelse(stage==2, stage.length+x, stage.length))
  
  A <- with(td, createProjectionMatrix(surv, fecund, stage.length))
  eig <- eigen(A, symmetric = FALSE)
  r <- Re(log(eig$values[1]))
  
  return(r)
})
sens.age <- data.frame(age=22+ages,r=sens.age)
sens.orig <- filter(sens.age,age==22)
ggplot(sens.age, aes(x=age, y=r)) +
  geom_line() +
  geom_abline(slope=0,intercept=0) +
  geom_point(data=sens.orig, aes(x=age, y=r), size=3) +
  theme_classic()

## Elasticities for matrix entries
mean_repro <- as.vector(Re(repro_value %*% turtleData$stage.dist))
E <- A*Re(outer(repro_value, turtleData$stage.dist))/(lambda*mean_repro)

Edata <- data.frame(expand.grid(stage = 1:7, param.type = c("P", "G", "F")),
                    e = c(diag(E), c(diag(E[-1,-dim(A)[1]]), 0), E[1,]))

# Plot elasticities for the matrix entries
ggplot(Edata, aes(x = stage, y = e, shape = param.type)) +
  geom_point() +
  geom_line(size=0.1) +
  xlab("Stage") +
  ylab("Elasticity") +
  scale_x_discrete(limits=1:7)+
  guides(shape=guide_legend(title=NULL)) +
  scale_shape_manual(values=c(2,0,1),
                     name="",
                     breaks=c("P", "G", "F"),
                     labels=c("Survival", "Growth", "Fecundity"))+
  theme_classic()

## Elasticities of stage-specific survival and stage duration FIXME
## Following Caswell 2001
P <- diag(A)
G <- c(diag(A[-1,-dim(A)[1]]), 0)

# Vaguely following p233, doesn't seem to work
#(P/lambda) * select(filter(Edata, param.type == "P"), e) + (G/lambda) * select(filter(Edata, param.type == "G"), e)

#(turtleData$surv/(turtleData$stage.length*lambda))*(select(filter(Edata, param.type == "G"), e) - select(filter(Edata, param.type == "P"), e))

# Using Caswell p219-220 (9.43) and (9.46)
# This is the right pattern but not the same values as Fig 4 of Crouse et al.
deltaV <- c(diff(repro_value),0)
E.surv <- (turtleData$surv/lambda)*(Re((repro_value+deltaV/turtleData$stage.length)*turtleData$stage.dist)/mean_repro)

# This is way off mark
E.dur <- (1/(turtleData$stage.length*lambda))*turtleData$surv*turtleData$stage.dist*deltaV/mean_repro


## Management scenarios

# 1. increase survival in stages 2, 3, and 4 to 0.80
# 2. increase survival in stages 3 and 4 to 0.80, increase adult survival to 0.85
# 3. decrease survival in first-year to 0.33735, increase survival for stages 3
#    and 4 to 0.80 and for adults to 0.85

td <- turtleData %>% mutate(surv.s1 = replace(surv, stage %in% 2:4, 0.8),
                            surv.s2 = ifelse(stage %in% 3:4, 0.8,
                                             ifelse(stage %in% 5:7, 0.85, surv)),
                            surv.s3 = ifelse(stage==1, 0.5*surv,
                                             ifelse(stage %in% 3:4, 0.8,
                                                    ifelse(stage %in% 5:7, 0.85, surv))))

mod.s1 <- with(td, getMPM(surv.s1, fecund, stage.length))
round(l1 <- mod.s1$lambda, digits=2)
round(r1 <- log(l1), digits=2)

mod.s2 <- with(td, getMPM(surv.s2, fecund, stage.length))
round(l2 <- mod.s2$lambda, digits=2)
round(r2 <- log(l2), digits=2)

mod.s3 <- with(td, getMPM(surv.s3, fecund, stage.length))
round(l3 <- mod.s3$lambda, digits=2)
round(r3 <- log(l3), digits=2)

## What increase in survival at stages 2,3,4, and 7 is required to achieve
## stability (lambda = 1, r = 0)?
stages <- c(2,3,4,7)
tol <- 1e-2
surv.final <- sapply(stages, function(x) {
  cand <- lower <- turtleData[x,"surv"]
  upper <- 1
  while(lambda < 1 || upper - lower > tol) {
    cand <- (upper + lower)/2
    td <- turtleData %>% mutate(surv=replace(surv, stage==x, cand))
    mod <- with(td, getMPM(surv, fecund, stage.length))
    lambda <- mod$lambda
    if (lambda < 1) {
      lower <- cand
    } else {
      upper <- cand
    }
  }
  return (cand)
})
round(surv.final, digits=3)
with(turtleData, round(surv.final/surv[stages], digits=3))