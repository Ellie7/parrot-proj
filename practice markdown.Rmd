---
title: "Crouse 1987 Analysis"
author: "Ellie"
date: "14 October 2017"
output:
  pdf_document: default
  html_document: default
---
The code below demonstrates my attempt to re-create the analysis from Crouse's 1987 paper on loggerhead turtle demography. 

**Creating the Crouse 1987 Matrix** 

Creating a stage-based projection matrix, for each stage, 
calculating the repro- ductive output (F,), the probability of surviving and growing into the next stage (G,). and the probability of surviving and 
remaining in the same stage (P,).

```{r include = FALSE}
library(dplyr)
library(knitr)
parrot-proj/table 3 from crouse.csv
table.3 <- read.csv("~/1 UNIVERSITY/Level 4/Project & Dissertation/Crouse 1987/table 3 from crouse.csv")
```
```{r}
fecs <- select(table.3, fecundity)
#starting values 
pi <- select(table.3, annual_survivorship)
di <-select(table.3, stage_duration)
#Ps
Pi <- ((1 - (pi^(di - 1)))/(1 - (pi^di)))*pi
# Pi's
#1              0.0000
#2              0.7371
#3              0.6611
#4              0.6907
#5              0.0000
#6              0.0000
#7              0.8086

#Gs
Gi <- (pi^di*(1 - pi))/(1 - pi^di) 
#life table (parts of anyway)
life_table <- data.frame(fecs, Gi, Pi)
##making the matrix: 
mat1 <- matrix(NA, nrow = 7, ncol = 7, byrow = T) 
#fill with fecundity 
mat1[1,] <- life_table$fecundity 
#add Ps 
mat1[1,1] <- Pi$annual_survivorship[1] 
mat1[2,2] <- Pi$annual_survivorship[2] 
mat1[3,3] <- Pi$annual_survivorship[3]
mat1[4,4] <- Pi$annual_survivorship[4]
mat1[5,5] <- Pi$annual_survivorship[5]
mat1[6,6] <- Pi$annual_survivorship[6]
mat1[7,7] <- Pi$annual_survivorship[7]
mat1
#add Gs 
mat1[2,1] <- Gi$annual_survivorship[1]
mat1[3,2] <- Gi$annual_survivorship[2]
mat1[4,3] <- Gi$annual_survivorship[3]
mat1[5,4] <- Gi$annual_survivorship[4]
mat1[6,5] <- Gi$annual_survivorship[5]
mat1[7,6] <- Gi$annual_survivorship[6] 
mat1
#remove NAs
#shows location of NAs
is.na(mat1)
#replaces NAs with 0s
mat1[is.na(mat1)] <- 0
mat1#almost there 
A <- mat1  
```
**Have started trying to make a function for 'matrixing'**
```{r}
#{
#  fecs <- select(table.3, fecundity)
#  pi <- select(table.3, annual_survivorship)
#  di <-select(table.3, stage_duration)
#  Pi <- ((1 - (pi^(di - 1)))/(1 - (pi^di)))*pi
#  Gi <- (pi^di*(1 - pi))/(1 - pi^di)
#  mat1 <- matrix(0, nrow = 7, ncol = 7)
#  for (i in 2:7) {
#    for (j in 2:7) mat1[i, j] <- {
#     x <- subset(stage_duration, stage_duration == j)
#      jT <- nrow(x)
#      iT <- sum(x$stage_duration == i)
#      iT/jT
#    }
#  }
#  #add Fs
#  mat1[1,] <- life_table$fecundity 
#  #add Ps 
#  mat1[1,1] <- Pi$annual_survivorship[1] 
#  mat1[2,2] <- Pi$annual_survivorship[2] 
#  mat1[3,3] <- Pi$annual_survivorship[3]
#  mat1[4,4] <- Pi$annual_survivorship[4]
#  mat1[5,5] <- Pi$annual_survivorship[5]
#  mat1[6,6] <- Pi$annual_survivorship[6]
#  mat1[7,7] <- Pi$annual_survivorship[7]
# mat1
#  #add Gs 
#  mat1[2,1] <- Gi$annual_survivorship[1]
#  mat1[3,2] <- Gi$annual_survivorship[2]
#  mat1[4,3] <- Gi$annual_survivorship[3]
#  mat1[5,4] <- Gi$annual_survivorship[4]
#  mat1[6,5] <- Gi$annual_survivorship[5]
#  mat1[7,6] <- Gi$annual_survivorship[6] 
#  return(mat1)
# }
```
**Stage structure growth (multiple steps)**
```{r echo = FALSE}
N0 <- matrix(c(10000,10000,10000,10000,10000,10000,10000), ncol=1)
years <- 20
N.projections <- matrix(0, nrow = nrow(A), ncol = years + 1) 
N.projections[,1] <- N0 
for (i in 1:years) 
  {N.projections[, i + 1] <- A %*% N.projections[, i] 
matplot(0:years, t(N.projections), type = "l", lty = 1:3, 
        col = 1, ylab = "Stage Abundance", xlab = "Year")}
```
**Annual growth rate**
```{r echo = FALSE}
N.totals <- apply(N.projections, 2, sum)
Rs <- N.totals[-1]/N.totals[-(years + 1)]
plot(0:(years - 1), Rs, type = "b", xlab = "Year", ylab = "R") 
```
**Eigen analysis** 
```{r echo = FALSE} 
eigs.A <- eigen(A)
eigs.A
```
**Finding the first eigenvalue (finite rate of increase)**
```{r echo = FALSE} 
dom.pos <- which.max(eigs.A[["values"]])
L1 <- Re(eigs.A[["values"]][dom.pos])
L1
```
**Power method** 
using N0 <- matrix(c(1000,1000,1000,1000,1000,1000,1000), ncol=1) as a subsitute for actual data 
```{r}
t <- 20
Nt <- N0/sum(N0)
R.t <- numeric(t)
for (i in 1:t) R.t[i] <- {
  Nt1 <- A %*% Nt
  R <- sum(Nt1)/sum(Nt)
  R
} 
```
You might need to adjust the number of iterations to make sure the value has stabilised (how can you tell that it has?).
Can you do it by creating the convergence towards lambda plot? 
```{r}
par(mar = c(5,4,3,2))
plot(1:t, R.t, type = "b", main = quote("Convergence Toward"* lambda))
points(t, L1, pch = 19, cex = 1.5)
```
graph shows immediate convergence to lambda, don't know whats wrong and I think it should be converging to 0.945031? 

**Calculating the stable stage distribution** 
```{r echo = FALSE}
w <- Re(eigs.A[["vectors"]][, dom.pos])
ssd <- w / sum(w)
stable <- round(ssd,3)
stable
```
**Calculating the reproductive value** 
```{r echo = FALSE}
M <- eigen(t(A))
v <- Re(M$vectors[,which.max(Re(M$values))])
RV <- v / v[1]
RV 
```
**Created table 5 (from Crouse 1987)** 
```{r echo = FALSE}
tab <- select(table.3, stage_number, class)
tab_5<- data.frame(tab, stable, RV)
colnames(tab_5) <- c("Stage number", "Stage Class", "Stable stage distribution (Dominant eigenvector)", "Reproductive values (left eigenvector)" )
kable(tab_5, caption = "Table 5. Stable stage distribution and reproductive values for the loggerhead population matrix given in Table 4.")
```
