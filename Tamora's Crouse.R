## This script follows the matrix population model methods in Crouse 1987 to produce equivalent analyses.

## Reference
## Title: A Stage-Based Population Model for Loggerhead Sea Turtles and Implications for Conservation
## Author(s): Deborah T. Crouse, Larry B. Crowder and Hal Caswell
## Source: Ecology, Vol. 68, No. 5 (Oct., 1987), pp. 1412-1423
## Published by: Ecological Society of America
## Stable URL: http://www.jstor.org/stable/1939225

rm(list=ls())

## ---- libs ----
library(dplyr)
library(ggplot2)
library(gridExtra)
source(file = "loggerhead_fun.R")

## ---- dataimport ----
turtleData <- read.csv("loggerhead_crouse1987.csv") %>%
  mutate(stage_length = max.age - min.age)

A <- with(turtleData, createProjectionMatrix(surv, fecund, stage_length))
print(A, digits=4)

## ---- eigen ----
## Crouse 1987 calculates the eigenvalues and eigenvectors using the power
## method (Searle 1966, Keyfitz 1977).
## (See p205 of Trefethen and Bau for this algorithm, which the authors note is
## not a very effective method for finding eigenvalues/eigenvectors.)
## Here we'll use just use eigen() to get our eigenvalues and vectors. This
## gives a reasonably good approximation to the values of lambda_m= 0.9450 and
## r = -0.0565 generated by Crouse.
eig <- eigen(A, symmetric = FALSE)
lambda <- Re(eig$values[1])
r <- log(lambda)

## ---- ssd ----
## The stable stage distribution is given by the right eigenvector (coerced here
## to its real part).
w1 <- Re(eig$vectors[,1])
turtleData <- mutate(turtleData, stage_dist = w1/sum(w1))

## ---- ssd-plot ----
ggplot(turtleData, aes(x = stage, y = stage_dist))+
  geom_bar(stat="identity", fill="grey", width = 0.8)+
  xlab("Stage")+
  ylab("Proportion of individuals")+
  scale_x_discrete(limits=turtleData$class)+
  #scale_y_continuous(limits=c(0, 1))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45, hjust=1, size=12),
        axis.line.x = element_line(lineend = 0.5))

## ---- repro-val ----
## The reproductive value is given by the left eigenvector, which we get by
## calculating the eigenvectors of the transpose of the projection matrix.
v1 <- eigen(t(A), symmetric = FALSE)$vectors[,1]
turtleData <- mutate(turtleData, repro_val = Re(v1/v1[1]))

## ---- ssd-repro-val ----
print(select(turtleData, class, stage_dist, repro_val), digits=3)

## ---- mean-repro ----
## Mean reproductive value
mean_repro <- with(turtleData, as.vector(Re(repro_val %*% stage_dist)))
print(mean_repro, digits=4)

## ---- sensitivity ----
## Sensitivity analyses
## a. Reduction in fecundity and mortality by 50%
## b. Doubling in fecundity and elimination of mortality
perm <- rbind(c(1,0), cbind(F=0, S=1:7))
sens_grow <- t(apply(perm, MARGIN = 1, function(x) {
  td <- turtleData %>% mutate(surv_dec = ifelse(stage==x["S"], surv*0.5, surv),
                              fecund_dec = ifelse(x["F"],0.5,1)*fecund,
                              surv_inc = ifelse(stage==x["S"], 0.99, surv),
                              fecund_inc = ifelse(x["F"],2,1)*fecund)
  
  A <- with(td, createProjectionMatrix(surv_dec, fecund_dec, stage_length))
  eig <- eigen(A, symmetric = FALSE)
  r_dec <- Re(log(eig$values[1]))
  
  A <- with(td, createProjectionMatrix(surv_inc, fecund_inc, stage_length))
  eig <- eigen(A, symmetric = FALSE)
  r_inc <- Re(log(eig$values[1]))
  
  return(c(grow_dec=r_dec, grow_inc=r_inc))
}))
sens_grow <- data.frame(perm, sens_grow)

## ---- sens-plot ----
lim=c(min(sens_grow$grow_dec, sens_grow$grow_inc),
      max(sens_grow$grow_dec, sens_grow$grow_inc))

p1 <- ggplot(sens_grow, aes(x = S+1, y = grow_dec))+
  geom_bar(stat="identity", position = "identity",
           fill="grey", width = 0.8)+
  geom_abline(slope = 0, intercept = 0)+
  geom_abline(slope = 0, intercept = r, linetype="dotted")+
  ggtitle("Decrease in fecundity or survivorship")+
  xlab("Vital rate parameter")+
  ylab("Intrinic rate of increase")+
  scale_x_discrete(limits = c("fecundity", as.character(turtleData$class)))+
  scale_y_continuous(limits = lim)+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45, hjust=1, size=10),
        axis.title = element_text(hjust=0.5),
        title = element_text(size=9.5, face='bold', hjust=0.1))

p2 <- ggplot(sens_grow, aes(x = S+1, y = grow_inc))+
  geom_bar(stat="identity", position = "identity",
           fill="grey", width = 0.8)+
  geom_abline(slope = 0, intercept = 0)+
  geom_abline(slope = 0, intercept = r, linetype="dotted")+
  ggtitle("Increase in fecundity or survivorship")+
  xlab("Vital rate parameter")+
  ylab("Intrinic rate of increase")+
  scale_x_discrete(limits = c("fecundity", as.character(turtleData$class)))+
  scale_y_continuous(limits = lim)+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45, hjust=1, size=10),
        axis.title = element_text(hjust=0.5),
        title = element_text(size=9.5, face='bold', hjust=0.1))

## ---- sens-plot-output ----
## Arrange plots in single column
grid.arrange(p1, p2, ncol=1)

## ---- sens-age ----
## Sensitivity to age at first reproduction
ages <- seq(-2, 2, by = 1)
stages <- 2:4
sens_age <- sapply(ages, function(x) {
  td <- turtleData %>%
    mutate(stage_length = ifelse(stage %in% stages, stage_length+x, stage_length))
  
  A <- with(td, createProjectionMatrix(surv, fecund, stage_length))
  eig <- eigen(A, symmetric = FALSE)
  r <- Re(log(eig$values[1]))
  
  return(r)
})

## ---- sens-age-plot ----
sens_age <- data.frame(age = 22+length(stages)*ages, r = sens_age)
sens_orig <- filter(sens_age, age == 22)
ggplot(sens_age, aes(x = age, y = r)) +
  geom_line() +
  geom_abline(slope = 0, intercept = 0) +
  geom_point(size = 1) +
  xlab("Age at first reproduction") +
  ylab("Intrinic rate of increase") +
  geom_text(x = 23, y = sens_orig$r, label = "base run") +
  theme_classic()

## ---- elas ----
## Elasticities for matrix entries
S <- with(turtleData, Re(outer(repro_val, stage_dist))/mean_repro)
E <- (A/lambda)*S

## ---- elas-plot ----
Edata <- data.frame(expand.grid(stage = 1:7, param_type = c("P", "G", "F")),
                    e = c(diag(E), c(diag(E[-1,-dim(A)[1]]), 0), E[1,]))

# Plot elasticities for the matrix entries
ggplot(Edata, aes(x = stage, y = e, shape = param_type)) +
  geom_point(size = 2.3) +
  geom_line(size = 0.1) +
  xlab("Stage") +
  ylab("Elasticity") +
  scale_x_discrete(limits = 1:7)+
  guides(shape = guide_legend(title = NULL)) +
  scale_shape_manual(values = c(2,0,1),
                     name = "",
                     breaks = c("P", "G", "F"),
                     labels = c("Survival", "Growth", "Fecundity"))+
  theme_classic()

## ---- elas-vr ----

## Elasticity of lambda to stage-specific survival and stage duration

## 1. Stage-specific survival

## ---- elas-surv-pd ----
## Calculate partial derivatives of P and G with respect to survival
d <- turtleData$stage_length
p <- turtleData$surv
dP_dp <- (1 - d*p^(d-1) + (d-1)*p^d)/(1-p^d)^2
dG_dp <- (d*p^(d-1) - (d+1)*p^d + p^(2*d))/(1-p^d)^2

## ---- elas-surv-calc ----
## Create the matrix of partial derivatives and set the diagonal to dP_dp and
## the sub-diagonal to dG_dp
D <- diag(dP_dp)
diag(D[-1,-length(p)]) <- dG_dp[1:(length(p)-1)]

## Elasticity calculation
E_surv <- (p/lambda) * colSums(S * D)

## ---- elas-surv-plot ----
## Plot elasticity
elas <- data.frame(stage = 1:7, surv = E_surv)
p1 <- ggplot(elas, aes(x = stage, y = surv)) +
  geom_point(pch = 1) +
  geom_line(size = 0.1) +
  xlab("Stage") +
  ylab("Elasticity") +
  scale_x_discrete(limits = 1:7) +
  theme_classic()
p1

## ---- elas-vr-other ----

## Following Caswell 2001
P <- diag(A)
G <- c(diag(A[-1,-dim(A)[1]]), 0)

# Vaguely following p233, doesn't seem to work
#(P/lambda) * select(filter(Edata, param_type == "P"), e) + (G/lambda) * select(filter(Edata, param_type == "G"), e)

#(turtleData$surv/(turtleData$stage_length*lambda))*(select(filter(Edata, param_type == "G"), e) - select(filter(Edata, param_type == "P"), e))

# Using Caswell p219-220 (9.43) and (9.46)
# This is the right pattern but not the same values as Fig 4 of Crouse et al.
deltaV <- c(diff(turtleData$repro_val),0)
Esurv <- with(turtleData, (surv/lambda)*(Re((repro_val+deltaV/stage_length)*stage_dist)/mean_repro))

# This is way off mark - need to calculate growth transition from stage duration
Edur <- with(turtleData, (1/(stage_length*lambda))*surv*stage_dist*deltaV/mean_repro)

# Plot elasticities for raw parameters
elas <- data.frame(stage = 1:7, surv = Esurv, dur = Edur)
p1 <- ggplot(elas, aes(x = stage, y = surv)) +
  geom_point(pch = 1) +
  geom_line(size = 0.1) +
  xlab("Stage") +
  ylab("Elasticity") +
  scale_x_discrete(limits = 1:7) +
  theme_classic()
p2 <- ggplot(elas, aes(x = stage, y = dur)) +
  geom_point(pch = 1) +
  geom_line(size = 0.1) +
  xlab("Stage") +
  ylab("Elasticity") +
  scale_x_discrete(limits = 1:7) +
  theme_classic()

## ---- elas-plot-output ----
grid.arrange(p1, p2, ncol=1)

## ---- elas-vr-simple ----
## Alternative approach: make small change to vital rate, determine corresponding change in lambda

sens_vr <- lapply(1:7, function(x) {
  td <- turtleData %>% mutate(surv_adj = ifelse(stage == x, surv*1.01, surv),
                              surv_diff = surv_adj - surv,
                              dur_adj = ifelse(stage == x, stage_length*1.01, stage_length),
                              dur_diff = dur_adj - stage_length)
  
  A <- with(td, createProjectionMatrix(surv_adj, fecund, stage_length))
  eig <- eigen(A, symmetric = FALSE)
  lam_adj <- Re(eig$values[1])
  sens_surv <- (lam_adj - lambda)/td$surv_diff[x]
  elas_surv <- sens_surv*td$surv[x]/lambda
  
  A <- with(td, createProjectionMatrix(surv, fecund, dur_adj))
  eig <- eigen(A, symmetric = FALSE)
  lam_adj <- Re(eig$values[1])
  sens_dur <- (lam_adj - lambda)/td$dur_diff[x]
  elas_dur <- sens_dur*td$stage_length[x]/lambda
  
  data.frame(stage = x, vr = c("D", "S"), sens = c(sens_dur, sens_surv), elas = c(elas_dur, elas_surv))
})
sens_vr <- do.call(rbind, sens_vr) %>%
  mutate(vr = factor(vr, levels = c("S", "D"), label = c("Survival", "Stage duration")))

## ---- sens-plot-output-vr-simple ----

## Plot sensitivities
ggplot(sens_vr, aes(stage, sens)) +
  geom_point(pch = 1) +
  facet_wrap(~vr, ncol = 1, scales = "free") +
  labs(x = "Stage", y = "Sensitivity") +
  theme_bw() +
  theme(aspect.ratio = 1.3)

## ---- elas-plot-output-vr-simple ----

## Plot elasticities
ggplot(sens_vr, aes(stage, elas)) +
  geom_point(pch = 1) +
  facet_wrap(~vr, scales = "free") +
  labs(x = "Stage", y = "Elasticity") +
  theme_bw() +
  theme(aspect.ratio = 1.3)

## ---- Management scenarios ----

# 1. increase survival in stages 2, 3, and 4 to 0.80
# 2. increase survival in stages 3 and 4 to 0.80, increase adult survival to 0.85
# 3. decrease survival in first-year to 0.33735, increase survival for stages 3
#    and 4 to 0.80 and for adults to 0.85

## ---- scenarios ----
td <- turtleData %>% mutate(surv_s1 = replace(surv, stage %in% 2:4, 0.8),
                            surv_s2 = ifelse(stage %in% 3:4, 0.8,
                                             ifelse(stage %in% 5:7, 0.85, surv)),
                            surv_s3 = ifelse(stage == 1, 0.5*surv,
                                             ifelse(stage %in% 3:4, 0.8,
                                                    ifelse(stage %in% 5:7, 0.85, surv))))

mod_s1 <- with(td, getMPM(surv_s1, fecund, stage_length))
mod_s2 <- with(td, getMPM(surv_s2, fecund, stage_length))
mod_s3 <- with(td, getMPM(surv_s3, fecund, stage_length))

lambdas <- c(mod_s1$lambda, mod_s2$lambda, mod_s3$lambda)
round(cbind(lambda=lambdas, r=log(lambdas)), digits=2)

## ---- stability ----
## What increase in survival at stages 2, 3, 4, and 7 is required to achieve
## stability (lambda = 1, r = 0)?
stages <- c(2,3,4,7)
tol <- 1e-2
surv_final <- sapply(stages, function(x) {
  cand <- lower <- turtleData[x,"surv"]
  upper <- 1
  lambda <- 0
  while(lambda < 1 || upper - lower > tol) {
    cand <- (upper + lower)/2
    td <- turtleData %>% mutate(surv = replace(surv, stage==x, cand))
    mod <- with(td, getMPM(surv, fecund, stage_length))
    lambda <- mod$lambda
    if (lambda < 1) {
      lower <- cand
    } else {
      upper <- cand
    }
  }
  return (cand)
})
with(turtleData, round(rbind(surv_final, increase = surv_final/surv[stages]), digits=3))